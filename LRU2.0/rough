// A utility function to access the last frame of queue
// QNode* deQueue(Queue* queue)
// {
// 	// Change rear and remove the previous rear
// 	QNode* temp = queue->rear;
// 	queue->rear = queue->rear->prev;

// 	if (queue->rear)
// 		queue->rear->next = NULL;
// 	// decrement the number of full frames by 1
// 	queue->count--;
//     return temp;
// }





// A utility function to get a new node
// QNode* newQNode(Queue* queue, Hash* hash, unsigned key_passed)
// {   
//     QNode* newBuff = NULL;
// 	//get_buffer from buffer pool
// 	pthread_spin_lock(&buffer_lock);

// 	if (buffer_count != 0 ) { 
//         newBuff = get_buffer(root);	
// 		newBuff->next = (QNode *)root->next;
// 		newBuff->prev = NULL;
// 		newBuff->key = key_passed;
// 		newBuff->ref_count++;

// 		thread_spin_unlock(&buffer_lock);
// 		return newBuff;
// 	}

// 	thread_spin_unlock(&buffer_lock);
// 	newBuff = evict(queue, key_passed);
// 	return newBuff;
// }

	// else{ 
	// 	//taking node level locks on the last and the second last node
	// 	// before calling dequeue()
	// 	QNode* lastNode = queue->rear;
	// 	QNode* leftNode = queue->rear->prev;
	// 	int retry = 1;

	// 	while (retry != 0) {
	// 		node_tl = pthread_spin_trylock(&lastNode->node_lock);
	// 		left_node_tl = pthread_spin_trylock(&leftNode->node_lock);

	// 		if ((node_tl == 0) && (left_node_tl == 0)) {
	// 			retry = 0;
	// 			break;
	// 			}
	// 		else {
	// 			pthread_spin_unlock(&leftNode->node_lock);
	// 			pthread_spin_unlock(&lastNode->node_lock);
	// 			}
	// 		}

	// 	hash->array[queue->rear->key] = NULL;
	// 	newBuff = deQueue(queue);
	// 	newBuff->ref_count++;
	// 	newBuff->key = key_passed;
		
	// 	pthread_spin_unlock(&leftNode->node_lock);
	// 	pthread_spin_unlock(&lastNode->node_lock);
	// 	return newBuff;
	// }

// }

	// // if the requested pagenumber is already infront of queue do nothing
	// if (reqPage == queue->front) {}

	// else {
	// 	// Unlink rquested page from its current location in queue
	// 	reqPage->prev->next = reqPage->next;
	// 	if (reqPage->next)
	// 		reqPage->next->prev = reqPage->prev;

	// 	// If the requested page is rear, then change rear
	// 	// as this node will be moved to front
	// 	if (reqPage == queue->rear) {
	// 		queue->rear = reqPage->prev;
	// 		queue->rear->next = NULL;
	// 	}
	// 	// Put the requested page before current front
	// 	reqPage->next = queue->front;
	// 	reqPage->prev = NULL;

	// 	// Change prev of current front
	// 	reqPage->next->prev = reqPage;

	// 	// Change front to the requested page
	// 	queue->front = reqPage;
	// }

	// if( clock_gettime( CLOCK_REALTIME, &stop_2) == -1 ) {
	// 		perror( "clock gettime" );
	// 		// return EXIT_FAILURE;
	// }
	// pthread_spin_unlock(&LRU_lock);

	// if( clock_gettime( CLOCK_REALTIME, &stop_3) == -1 ) {
	// 		perror( "clock gettime" );
	// 		// return EXIT_FAILURE;
	// }

	// accum_1 = (uint64_t)(( stop_1.tv_sec - start_1.tv_sec )*(uint64_t)BILLION) + (uint64_t)( stop_1.tv_nsec - start_1.tv_nsec);
	// accum_2 = (uint64_t)(( stop_2.tv_sec - stop_1.tv_sec )*(uint64_t)BILLION) + (uint64_t)( stop_2.tv_nsec - stop_1.tv_nsec);
	// accum_3 = (uint64_t)(( stop_3.tv_sec - stop_2.tv_sec )*(uint64_t)BILLION) + (uint64_t)( stop_3.tv_nsec - stop_2.tv_nsec);
	// accum_4 = (uint64_t)(( stop_3.tv_sec - start_1.tv_sec )*(uint64_t)BILLION) + (uint64_t)( stop_3.tv_nsec - start_1.tv_nsec);

	// printf("> Time taken b/w lock to *ACCESS* page number: %d is lock : %ld main_logic : %ld unlock : %ld access call : %ld\n",queue->front->pageNumber, accum_1, accum_2, accum_3, accum_4);


	// free logic

		// if reqPage is the root
		if (queue->front == reqPage)
			queue->front = reqPage->next;
		
		// Change next only if node to be deleted is NOT the last node
		if (reqPage->next != NULL)
			reqPage->next->prev = reqPage->prev;
	
		// Change prev only if node to be deleted is NOT the first node
		if (reqPage->prev != NULL)
			reqPage->prev->next = reqPage->next;